---
tag:
  - EDA
  - WiKi
  - 技术
---

# Application of compiler in EDA

![Compiler Pipeline](/assets/compiler-pipeline.png)

> In computing, a [Compiler](https://en.wikipedia.org/wiki/Compiler) is a computer program that translates computer code written in one programming language (the source language) into another language (the target language). The name "compiler" is primarily used for programs that translate source code from a high-level programming language to a low-level programming language (e.g. assembly language, object code, or machine code) to create an executable program.

## Parser

> A [parser](https://en.wikipedia.org/wiki/Parsing#Parser) is a software component that takes input data (typically text) and builds a data structure – often some kind of parse tree, abstract syntax tree or other hierarchical structure, giving a structural representation of the input while checking for correct syntax. The parsing may be preceded or followed by other steps, or these may be combined into a single step. The parser is often preceded by a separate lexical analyser, which creates tokens from the sequence of input characters; alternatively, these can be combined in scannerless parsing. Parsers may be programmed by hand or may be automatically or semi-automatically generated by a parser generator. Parsing is complementary to templating, which produces formatted output. These may be applied to different domains, but often appear together, such as the scanf/printf pair, or the input (front end parsing) and output (back end code generation) stages of a compiler.

### Deserialization

- Binary

[ALTIUM_BINARY_PARSER](https://gitlab.com/kicad/code/kicad/-/blob/master/common/io/altium/altium_binary_parser.h)

```cpp
class ALTIUM_BINARY_PARSER
{
public:
    template <typename Type>
    Type Read();

    template <typename Type>
    Type Peek();


    std::map<uint32_t, wxString> ReadWideStringTable();

    std::vector<char> ReadVector( size_t aSize );

    int ReadBytes( char* aOut, size_t aSize );

    std::map<wxString, wxString> ReadProperties(
            std::function<std::map<wxString, wxString>( const std::string& )> handleBinaryData =
                    []( const std::string& ));

};

```

- Symbol expression

[SCH_IO_KICAD_SEXPR_PARSER](https://gitlab.com/kicad/code/kicad/-/blob/master/eeschema/sch_io/kicad_sexpr/sch_io_kicad_sexpr_parser.h)

```cpp
/**
 * Object to parser s-expression symbol library and schematic file formats.
 */
class SCH_IO_KICAD_SEXPR_PARSER : public SCHEMATIC_LEXER
{
public:
    /**
     * Parse the internal #LINE_READER object into \a aSheet.
     *
     * When \a aIsCopyableOnly is true, only schematic objects that are viewable on the canvas
     * for copy and paste purposes are parsed.  Other schematic content such as bus definitions
     * or instance data will throw an #IO_ERROR exception.
     *
     * When \a aIsCopyableOnly is false, full schematic file parsing is performed.
     *
     * @note This does not load any sub-sheets or decent complex sheet hierarchies.
     *
     * @param aSheet The #SCH_SHEET object to store the parsed schematic file.
     * @param aIsCopyableOnly Load only the schematic objects that can be copied into \a aSheet
     *                        if true.  Otherwise, load the full schematic file format.
     * @param aFileVersion The schematic file version to parser.  Defaults to the schematic
     *                     file being parsed when \a aIsCopyableOnly is false.
     */
    void ParseSchematic( SCH_SHEET* aSheet, bool aIsCopyablyOnly = false,
                         int aFileVersion = SEXPR_SCHEMATIC_FILE_VERSION );
};
```

_P.S. How the schematic is serialized_

[SCH_IO_KICAD_SEXPR](https://gitlab.com/kicad/code/kicad/-/blob/master/eeschema/sch_io/kicad_sexpr/sch_io_kicad_sexpr.h)

```cpp
class SCH_IO_KICAD_SEXPR : public SCH_IO
{
public:

    void SaveSchematicFile( const wxString& aFileName, SCH_SHEET* aSheet, SCHEMATIC* aSchematic,
                            const STRING_UTF8_MAP* aProperties = nullptr ) override;

private:
    void saveSymbol( SCH_SYMBOL* aSymbol, const SCHEMATIC& aSchematic, int aNestLevel,
                     bool aForClipboard, const SCH_SHEET_PATH* aRelativePath = nullptr );
    void saveField( SCH_FIELD* aField, int aNestLevel );
    void saveBitmap( SCH_BITMAP* aBitmap, int aNestLevel );
    void saveSheet( SCH_SHEET* aSheet, int aNestLevel );
    void saveJunction( SCH_JUNCTION* aJunction, int aNestLevel );
    void saveNoConnect( SCH_NO_CONNECT* aNoConnect, int aNestLevel );
    void saveBusEntry( SCH_BUS_ENTRY_BASE* aBusEntry, int aNestLevel );
    void saveLine( SCH_LINE* aLine, int aNestLevel );
    void saveShape( SCH_SHAPE* aShape, int aNestLevel );
    void saveRuleArea( SCH_RULE_AREA* aRuleArea, int aNestLevel );
    void saveText( SCH_TEXT* aText, int aNestLevel );
    void saveTextBox( SCH_TEXTBOX* aText, int aNestLevel );
    void saveTable( SCH_TABLE* aTable, int aNestLevel );
    void saveBusAlias( std::shared_ptr<BUS_ALIAS> aAlias, int aNestLevel );
    void saveInstances( const std::vector<SCH_SHEET_INSTANCE>& aSheets, int aNestLevel );

    void cacheLib( const wxString& aLibraryFileName, const STRING_UTF8_MAP* aProperties );
    bool isBuffering( const STRING_UTF8_MAP* aProperties );

};

```

### Serialization && Deserialization

- Json

[Bom Settings](https://gitlab.com/kicad/code/kicad/-/blob/master/include/settings/bom_settings.h)

```cpp
void to_json( nlohmann::json& j, const BOM_FIELD& f );
void from_json( const nlohmann::json& j, BOM_FIELD& f );


void to_json( nlohmann::json& j, const BOM_PRESET& f );
void from_json( const nlohmann::json& j, BOM_PRESET& f );

void to_json( nlohmann::json& j, const BOM_FMT_PRESET& f );
void from_json( const nlohmann::json& j, BOM_FMT_PRESET& f );

```

- Symbol Expression

[SExpression](https://github.com/LibrePCB/LibrePCB/blob/master/libs/librepcb/core/serialization/sexpression.h)

```cpp
class SExpression final {
public:
  QByteArray toByteArray() const;
  static SExpression parse(const QByteArray& content, const FilePath& filePath);
};
```

## Transpiler

> A source-to-source translator, source-to-source compiler (S2S compiler), transcompiler, or [transpiler](https://en.wikipedia.org/wiki/Source-to-source_compiler) is a type of translator that takes the source code of a program written in a programming language as its input and produces an equivalent source code in the same or a different programming language. A source-to-source translator converts between programming languages that operate at approximately the same level of abstraction, while a traditional compiler translates from a higher level programming language to a lower level programming language. For example, a source-to-source translator may perform a translation of a program from Python to JavaScript, while a traditional compiler translates from a language like C to assembly or Java to bytecode.[4] An automatic parallelizing compiler will frequently take in a high level language program as an input and then transform the code and annotate it with parallel code annotations (e.g., OpenMP) or language constructs (e.g. Fortran's forall statements).

- [SCH_IO_ALTIUM](https://gitlab.com/kicad/code/kicad/-/blob/master/eeschema/sch_io/altium/sch_io_altium.h)

```cpp
class SCH_IO_ALTIUM : public SCH_IO
{
public:
    SCH_SHEET* LoadSchematicFile( const wxString& aFileName, SCHEMATIC* aSchematic,
                                  SCH_SHEET*             aAppendToMe = nullptr,
                                  const STRING_UTF8_MAP* aProperties = nullptr ) override;
};

```

## Type Checker vs ERC

### Introduction

[Type Checker](https://en.wikipedia.org/wiki/Type_system)

> In computer programming, a type system is a logical system comprising a set of rules that assigns a property called a type (for example, integer, floating point, string) to every term (a word, phrase, or other set of symbols). Usually the terms are various language constructs of a computer program, such as variables, expressions, functions, or modules.[1] A type system dictates the operations that can be performed on a term. For variables, the type system determines the allowed values of that term.

[Electrical Rule Check](https://resources.pcb.cadence.com/blog/2023-electrical-rule-check)

> An electrical rule check (ERC) ensures that integrated circuits work as they should. ERC makes sure a design follows a set of electrical rules defined by the designer or industry standards. ERC errors can lead to reduced yields or circuit malfunctions after delivery, so product success depends on finding and fixing them. Using connectivity and device information, ERC reviews electrical design rules. These checks are enabled by design rule checking (DRC) and layout versus schematic (LVS) verification tools.

### ERC Examples

- [KiCad ERC](https://gitlab.com/kicad/code/kicad/-/blob/master/eeschema/erc/erc.h)

```cpp
class ERC_TESTER
{
public:

    ERC_TESTER( SCHEMATIC* aSchematic ) :
            m_schematic( aSchematic )
    {
    }

    /**
     * Inside a given sheet, one cannot have sheets with duplicate names (file
     * names can be duplicated).
     *
     * @return the error count
     * @param aCreateMarker: true = create error markers in schematic,
     *                       false = calculate error count only
     */
    int TestDuplicateSheetNames( bool aCreateMarker );

    /**
     * Check for any unresolved text variable references.
     */
    void TestTextVars( DS_PROXY_VIEW_ITEM* aDrawingSheet );

    /**
     * Check that there are no conflicting bus alias definitions in the schematic.
     *
     * (for example, two hierarchical sub-sheets contain different definitions for
     * the same bus alias)
     *
     * @return the error count
     */
    int TestConflictingBusAliases();

    /**
     * Test if all units of each multiunit symbol have the same footprint assigned.
     * @return The error count.
     */
    int TestMultiunitFootprints();

    /**
     * In KiCad 5 and earlier, you could connect stuff up to pins with NC electrical type.
     * In KiCad 6, this no longer results in those pins joining the net, so we need to warn about it
     * @return the error count
     */
    int TestNoConnectPins();

    /**
     * Checks the full netlist against the pin-to-pin connectivity requirements
     * @return the error count
     */
    int TestPinToPin()
  {
    ERC_SETTINGS&  settings = m_schematic->ErcSettings();
    const NET_MAP& nets     = m_schematic->ConnectionGraph()->GetNetMap();

    int errors = 0;

    for( const std::pair<NET_NAME_CODE_CACHE_KEY, std::vector<CONNECTION_SUBGRAPH*>> net : nets )
    {
          std::vector<ERC_SCH_PIN_CONTEXT>           pins;
          std::unordered_map<EDA_ITEM*, SCH_SCREEN*> pinToScreenMap;
          bool has_noconnect = false;

          for( CONNECTION_SUBGRAPH* subgraph: net.second )
          {
              if( subgraph->GetNoConnect() )
                  has_noconnect = true;

              for( SCH_ITEM* item : subgraph->GetItems() )
              {
                  if( item->Type() == SCH_PIN_T )
                  {
                      pins.emplace_back( static_cast<SCH_PIN*>( item ), subgraph->GetSheet() );
                      pinToScreenMap[item] = subgraph->GetSheet().LastScreen();
                  }
              }
          }

          std::sort( pins.begin(), pins.end(),
                    []( const ERC_SCH_PIN_CONTEXT& lhs, const ERC_SCH_PIN_CONTEXT& rhs )
                    {
                        int ret = StrNumCmp( lhs.Pin()->GetParentSymbol()->GetRef( &lhs.Sheet() ),
                                              rhs.Pin()->GetParentSymbol()->GetRef( &rhs.Sheet() ) );

                        if( ret == 0 )
                            ret = StrNumCmp( lhs.Pin()->GetNumber(), rhs.Pin()->GetNumber() );

                        if( ret == 0 )
                            ret = lhs < rhs; // Fallback to hash to guarantee deterministic sort

                        return ret < 0;
                    } );

          ERC_SCH_PIN_CONTEXT needsDriver;
          bool                hasDriver = false;

          // We need different drivers for power nets and normal nets.
          // A power net has at least one pin having the ELECTRICAL_PINTYPE::PT_POWER_IN
          // and power nets can be driven only by ELECTRICAL_PINTYPE::PT_POWER_OUT pins
          bool     ispowerNet  = false;

          for( ERC_SCH_PIN_CONTEXT& refPin : pins )
          {
              if( refPin.Pin()->GetType() == ELECTRICAL_PINTYPE::PT_POWER_IN )
              {
                  ispowerNet = true;
                  break;
              }
          }

          for( auto refIt = pins.begin(); refIt != pins.end(); ++refIt )
          {
              ERC_SCH_PIN_CONTEXT& refPin = *refIt;
              ELECTRICAL_PINTYPE refType = refPin.Pin()->GetType();

              if( DrivenPinTypes.contains( refType ) )
              {
                  // needsDriver will be the pin shown in the error report eventually, so try to
                  // upgrade to a "better" pin if possible: something visible and only a power symbol
                  // if this net needs a power driver
                  if( !needsDriver.Pin()
                      || ( !needsDriver.Pin()->IsVisible() && refPin.Pin()->IsVisible() )
                      || ( ispowerNet
                                  != ( needsDriver.Pin()->GetType()
                                        == ELECTRICAL_PINTYPE::PT_POWER_IN )
                          && ispowerNet == ( refType == ELECTRICAL_PINTYPE::PT_POWER_IN ) ) )
                  {
                      needsDriver = refPin;
                  }
              }

              if( ispowerNet )
                  hasDriver |= ( DrivingPowerPinTypes.count( refType ) != 0 );
              else
                  hasDriver |= ( DrivingPinTypes.count( refType ) != 0 );

              for( auto testIt = refIt + 1; testIt != pins.end(); ++testIt )
              {
                  ERC_SCH_PIN_CONTEXT& testPin = *testIt;

                  // Multiple pins in the same symbol that share a type,
                  // name and position are considered
                  // "stacked" and shouldn't trigger ERC errors
                  if( refPin.Pin()->IsStacked( testPin.Pin() ) && refPin.Sheet() == testPin.Sheet() )
                      continue;

                  ELECTRICAL_PINTYPE testType = testPin.Pin()->GetType();

                  if( ispowerNet )
                      hasDriver |= DrivingPowerPinTypes.contains( testType );
                  else
                      hasDriver |= DrivingPinTypes.contains( testType );

                  PIN_ERROR erc = settings.GetPinMapValue( refType, testType );

                  if( erc != PIN_ERROR::OK && settings.IsTestEnabled( ERCE_PIN_TO_PIN_WARNING ) )
                  {
                      std::shared_ptr<ERC_ITEM> ercItem =
                              ERC_ITEM::Create( erc == PIN_ERROR::WARNING ? ERCE_PIN_TO_PIN_WARNING :
                                                                            ERCE_PIN_TO_PIN_ERROR );
                      ercItem->SetItems( refPin.Pin(), testPin.Pin() );
                      ercItem->SetSheetSpecificPath( refPin.Sheet() );
                      ercItem->SetItemsSheetPaths( refPin.Sheet(), testPin.Sheet() );

                      ercItem->SetErrorMessage(
                              wxString::Format( _( "Pins of type %s and %s are connected" ),
                                                ElectricalPinTypeGetText( refType ),
                                                ElectricalPinTypeGetText( testType ) ) );

                      SCH_MARKER* marker = new SCH_MARKER( ercItem, refPin.Pin()->GetPosition() );
                      pinToScreenMap[refPin.Pin()]->Append( marker );
                      errors++;
                  }
              }
          }

          if( needsDriver.Pin() && !hasDriver && !has_noconnect )
          {
              int err_code = ispowerNet ? ERCE_POWERPIN_NOT_DRIVEN : ERCE_PIN_NOT_DRIVEN;

              if( settings.IsTestEnabled( err_code ) )
              {
                  std::shared_ptr<ERC_ITEM> ercItem = ERC_ITEM::Create( err_code );

                  ercItem->SetItems( needsDriver.Pin() );
                  ercItem->SetSheetSpecificPath( needsDriver.Sheet() );
                  ercItem->SetItemsSheetPaths( needsDriver.Sheet() );

                  SCH_MARKER* marker = new SCH_MARKER( ercItem, needsDriver.Pin()->GetPosition() );
                  pinToScreenMap[needsDriver.Pin()]->Append( marker );
                  errors++;
              }
          }
      }

      return errors;
    }


    /**
     * Checks if shared pins on multi-unit symbols have been connected to different nets
     * @return the error count
     */
    int TestMultUnitPinConflicts();

    /**
     * Checks for labels that differ only in capitalization
     * @return the error count
     */
    int TestSimilarLabels();

    /**
     * Test to see if there are potentially confusing 4-way junctions in the schematic.
    */
    int TestFourWayJunction();

    /**
     * Test symbols for changed library symbols and broken symbol library links.
     * @return the number of issues found
     */
    int TestLibSymbolIssues();

    /**
     * Test footprint links against the current footprint libraries.
     * @return the number of issues found
     */
    int TestFootprintLinkIssues( KIFACE* aCvPcb, PROJECT* aProject );

    /**
     * Test pins and wire ends for being off grid.
     * @return the error count
     */
    int TestOffGridEndpoints();

    /**
     * Test SPICE models for various issues.
     */
    int TestSimModelIssues();

    /**
     * Test for uninstantiated units of multi unit symbols
     */
    int TestMissingUnits();

    /**
     * Tests for netclasses that are referenced but not defined.
     * @return
     */
    int TestMissingNetclasses();

    /**
     * Tests for rule area ERC issues
     */
    int RunRuleAreaERC();

    /**
     * Runs ERC to check for overlapping rule areas
     */
    int TestRuleAreaOverlappingRuleAreasERC(
            std::map<SCH_SCREEN*, std::vector<SCH_RULE_AREA*>>& allScreenRuleAreas );

    void RunTests( DS_PROXY_VIEW_ITEM* aDrawingSheet, SCH_EDIT_FRAME* aEditFrame,
                   KIFACE* aCvPcb, PROJECT* aProject, PROGRESS_REPORTER* aProgressReporter );

};


```

- [LibrePCB ERC](https://github.com/LibrePCB/LibrePCB/blob/master/libs/librepcb/core/project/erc/electricalrulecheck.h)

```cpp
class ElectricalRuleCheck final {
public:
  // General Methods
  RuleCheckMessageList runChecks() const;

private:  // Methods
  void checkNetClasses(RuleCheckMessageList& msgs) const;
  void checkNetSignals(RuleCheckMessageList& msgs) const;
  void checkComponents(RuleCheckMessageList& msgs) const;
  void checkComponentSignals(const ComponentInstance& cmp,
                             RuleCheckMessageList& msgs) const;
  void checkSchematics(RuleCheckMessageList& msgs) const;
  void checkSymbols(const Schematic& schematic,
                    RuleCheckMessageList& msgs) const;
  void checkPins(const SI_Symbol& symbol, RuleCheckMessageList& msgs) const
  {
    foreach (const SI_SymbolPin* pin, symbol.getPins()) {
      if ((pin->getNetLines().isEmpty()) && (pin->getCompSigInstNetSignal())) {
        msgs.append(std::make_shared<ErcMsgConnectedPinWithoutWire>(*pin));
      }
    }
  }


  void checkNetSegments(const Schematic& schematic,
                        RuleCheckMessageList& msgs) const
  {
    foreach (const SI_NetSegment* netSegment, schematic.getNetSegments()) {
      checkNetPoints(*netSegment, msgs);

      // If there are no net labels, check for any open wire. But only if there's
      // no "open net" warning on the net raised, since this would be quite a
      // duplicate warning.
      if (netSegment->getNetLabels().isEmpty() &&
          (!mOpenNetSignals.contains(&netSegment->getNetSignal()))) {
        foreach (const SI_NetLine* netLine, netSegment->getNetLines()) {
          if (netLine->getStartPoint().isOpen() ||
              netLine->getEndPoint().isOpen()) {
            msgs.append(std::make_shared<ErcMsgOpenWireInSegment>(*netSegment));
            break;
          }
        }
      }
    }
  }
  void checkNetPoints(const SI_NetSegment& netSegment,
                      RuleCheckMessageList& msgs) const;
};


```

### Type Checker Example

- [python type checker](https://github.com/microsoft/pyright/blob/main/packages/pyright-internal/src/analyzer/checker.ts)

```ts
export class Checker extends ParseTreeWalker {
  override visitBinaryOperation(node: BinaryOperationNode): boolean {
    if (
      node.operator === OperatorType.And ||
      node.operator === OperatorType.Or
    ) {
      this._validateConditionalIsBool(node.leftExpression);
      this._validateConditionalIsBool(node.rightExpression);
    }

    if (
      node.operator === OperatorType.Equals ||
      node.operator === OperatorType.NotEquals
    ) {
      // Don't apply this rule if it's within an assert.
      if (!ParseTreeUtils.isWithinAssertExpression(node)) {
        this._validateComparisonTypes(node);
      }
    } else if (
      node.operator === OperatorType.Is ||
      node.operator === OperatorType.IsNot
    ) {
      // Don't apply this rule if it's within an assert.
      if (!ParseTreeUtils.isWithinAssertExpression(node)) {
        this._validateComparisonTypesForIsOperator(node);
      }
    } else if (
      node.operator === OperatorType.In ||
      node.operator === OperatorType.NotIn
    ) {
      // Don't apply this rule if it's within an assert.
      if (!ParseTreeUtils.isWithinAssertExpression(node)) {
        this._validateContainmentTypes(node);
      }
    }

    this._evaluator.getType(node);
    return true;
  }
}
```
